## 5. Recursion
​
1. The introduction mentions, "in Haskell by declaring what something is instead of declaring how you get it. That's why there are no while loops or for loops in Haskell and instead we many times have to use recursion to declare what something is."  This is often called (_declarative programming_)[https://en.wikipedia.org/wiki/Declarative_programming].  The opposite of declarative programming is (_imperative programming_)[https://en.wikipedia.org/wiki/Imperative_programming].
    a. What are some places in other languages or frameworks that express things declaratively?
    b. What are some domains that lend themselves well to declarative programming and what are some that are better suited to imperative programming?
2. They showed us quick-sort, now let's write merge-sort!
    a. Write a function `merge :: (Ord a) => [a] -> [a] -> [a]` that takes two sorted lists and merges them into one sorted list that is also sorted.
    b. Write a function `mergeSort :: (Ord a) => [a] -> [a]` that sorts a list by splitting the list in half and sorting each ot the sub-lists, then merging the sorted sub-lists back into a sorted listed. Use the `merge` function you wrote in part A and you may want to use the function `splitAt` which can be combined with `length` and `div` to split the list in half.
3. You might have been told in other languages to be careful with recursion because it can be very easy to get bad perfomance.  This can be true in Haskell, but it does a lot to help you out.  One thing it does is called (_tail-call optimization_)[https://en.wikipedia.org/wiki/Tail_call].  If the last thing you do in a function is call the function recursively then the compiler will get rid of the recursive call and just reuse the same memory, turning it into a loop!
    A. Take the `maximum` function from the chapter and make it tail-recursive.  One common trick is to use something called an `accumulator`.  Keep the edge cases the same, but in the recursive case add a new function in a `where` clause that has the signature `(Ord a) => a -> [a] -> a`.  This function will "store" the largest value seen in its first argument and return that when it runs out of values in the list.
    B. Use a similar trick to make the `replicate` function tail-recursive. In this case your accumulator will need to keep track of two variables, the list and the counter.
    C. In a previous chapter we implemented an infinite list of the fibonacci sequence using `zipWith`.  Write a function that will just calculate the Nth fibonacci number tail-recursively.  In this case your accumulator function will need to keep track of three variables: the counter and two values.  If you are having trouble, think about how you would implement it in a loop and how you would update each variable.
    D. It was hinted at in the last question, but any pure tail recursive function can be implemented as an imperative loop.  Can you prove that this is the case by describing a construction that takes any pure tail-recursive function with edge cases and produces a loop that does the same computation?